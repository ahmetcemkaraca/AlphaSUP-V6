/**
 * Payment API Routes
 * Ödeme işlemleri için API endpoint'leri
 */

import { Router } from 'express';
import * as expressValidator from 'express-validator';
import WebhookHandler from '../handlers/webhook';
import { AuthMiddleware } from '../middleware/auth';
import PaymentService from '../services/payment';

const router = Router();
const paymentService = new PaymentService();
const webhookHandler = new WebhookHandler();
const authMiddleware = new AuthMiddleware();

// Validation middleware
const validateRequest = (req: any, res: any, next: any) => {
    const errors = expressValidator.validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({
            success: false,
            error: {
                code: 'VALIDATION_ERROR',
                message: 'Invalid request data',
                details: errors.array(),
            },
        });
    }
    next();
};

/**
 * POST /api/payments/create-intent
 * Create payment intent for booking
 */
router.post('/create-intent',
    authMiddleware.authenticate,
    [
        expressValidator.body('bookingId').isString().notEmpty().withMessage('Booking ID is required'),
        expressValidator.body('amount').isFloat({ min: 0.01 }).withMessage('Amount must be greater than 0'),
        expressValidator.body('depositOnly').optional().isBoolean().withMessage('Deposit only must be boolean'),
        expressValidator.body('depositPercentage').optional().isFloat({ min: 1, max: 100 }).withMessage('Deposit percentage must be between 1-100'),
        expressValidator.body('currency').optional().isString().isLength({ min: 3, max: 3 }).withMessage('Currency must be 3 characters'),
        expressValidator.body('savePaymentMethod').optional().isBoolean().withMessage('Save payment method must be boolean'),
    ],
    validateRequest,
    async (req: any, res: any) => {
        try {
            const {
                bookingId,
                amount,
                depositOnly,
                depositPercentage,
                currency,
                savePaymentMethod,
            } = req.body;

            const { paymentIntent, clientSecret } = await paymentService.createPaymentIntent(
                bookingId,
                req.user.uid,
                amount,
                {
                    depositOnly,
                    depositPercentage,
                    currency,
                    savePaymentMethod,
                }
            );

            res.status(200).json({
                success: true,
                data: {
                    paymentIntentId: paymentIntent.id,
                    clientSecret,
                    amount: paymentIntent.amount,
                    currency: paymentIntent.currency,
                },
            });
        } catch (error: any) {
            console.error('Create payment intent error:', error);
            res.status(500).json({
                success: false,
                error: {
                    code: 'PAYMENT_INTENT_CREATION_FAILED',
                    message: error?.message || 'Failed to create payment intent',
                },
            });
        }
    }
);

/**
 * GET /api/payments/:paymentId
 * Get payment details
 */
router.get('/:paymentId',
    authMiddleware.authenticate,
    [
        param('paymentId').isString().notEmpty().withMessage('Payment ID is required'),
    ],
    validateRequest,
    async (req: any, res: any) => {
        try {
            const { paymentId } = req.params;
            const payment = await paymentService.getPayment(paymentId);

            if (!payment) {
                return res.status(404).json({
                    success: false,
                    error: {
                        code: 'PAYMENT_NOT_FOUND',
                        message: 'Payment not found',
                    },
                });
            }

            // Check if user owns this payment or is admin
            if (payment.customerId !== req.user.uid && !req.user.isAdmin) {
                return res.status(403).json({
                    success: false,
                    error: {
                        code: 'FORBIDDEN',
                        message: 'Access denied',
                    },
                });
            }

            res.status(200).json({
                success: true,
                data: payment,
            });
        } catch (error: any) {
            console.error('Get payment error:', error);
            res.status(500).json({
                success: false,
                error: {
                    code: 'PAYMENT_RETRIEVAL_FAILED',
                    message: error?.message || 'Failed to retrieve payment',
                },
            });
        }
    }
);

/**
 * GET /api/payments/booking/:bookingId
 * Get payments for booking
 */
router.get('/booking/:bookingId',
    authMiddleware.authenticate,
    [
        param('bookingId').isString().notEmpty().withMessage('Booking ID is required'),
    ],
    validateRequest,
    async (req: any, res: any) => {
        try {
            const { bookingId } = req.params;
            const payments = await paymentService.getPaymentsForBooking(bookingId);

            // Check if user owns this booking or is admin
            if (payments.length > 0 && payments[0].customerId !== req.user.uid && !req.user.isAdmin) {
                return res.status(403).json({
                    success: false,
                    error: {
                        code: 'FORBIDDEN',
                        message: 'Access denied',
                    },
                });
            }

            res.status(200).json({
                success: true,
                data: payments,
            });
        } catch (error: any) {
            console.error('Get booking payments error:', error);
            res.status(500).json({
                success: false,
                error: {
                    code: 'PAYMENT_RETRIEVAL_FAILED',
                    message: error?.message || 'Failed to retrieve payments',
                },
            });
        }
    }
);

/**
 * POST /api/payments/:paymentId/refund
 * Create refund for payment (Admin only)
 */
router.post('/:paymentId/refund',
    authMiddleware.authenticate,
    authMiddleware.requireAdmin,
    [
        param('paymentId').isString().notEmpty().withMessage('Payment ID is required'),
        body('amount').isFloat({ min: 0.01 }).withMessage('Amount must be greater than 0'),
        body('reason').isString().notEmpty().withMessage('Refund reason is required'),
        body('adminNotes').optional().isString().withMessage('Admin notes must be string'),
    ],
    validateRequest,
    async (req: any, res: any) => {
        try {
            const { paymentId } = req.params;
            const { amount, reason, adminNotes } = req.body;

            const refund = await paymentService.createRefund(
                paymentId,
                amount,
                reason,
                req.user.uid,
                {
                    adminNotes,
                }
            );

            res.status(200).json({
                success: true,
                data: refund,
            });
        } catch (error: any) {
            console.error('Create refund error:', error);
            res.status(500).json({
                success: false,
                error: {
                    code: 'REFUND_CREATION_FAILED',
                    message: error?.message || 'Failed to create refund',
                },
            });
        }
    }
);

/**
 * POST /api/payments/webhook/stripe
 * Stripe webhook endpoint
 */
router.post('/webhook/stripe',
    // Raw body middleware for webhook signature validation
    (req: any, _res: any, next: any) => {
        if (req.headers['content-type'] === 'application/json') {
            req.body = req.body; // Keep raw body for signature validation
        }
        next();
    },
    async (req: any, res: any) => {
        await webhookHandler.handleStripeWebhook(req, res);
    }
);

/**
 * GET /api/payments/config
 * Get payment configuration (public)
 */
router.get('/config', async (_req: any, res: any) => {
    try {
        res.status(200).json({
            success: true,
            data: {
                currency: 'try',
                allowedPaymentMethods: ['card', 'apple_pay', 'google_pay'],
                defaultDepositPercentage: 30,
                minimumAmount: 1, // 1 TL minimum
            },
        });
    } catch (error: any) {
        console.error('Get payment config error:', error);
        res.status(500).json({
            success: false,
            error: {
                code: 'CONFIG_RETRIEVAL_FAILED',
                message: 'Failed to retrieve payment configuration',
            },
        });
    }
});

export default router;
